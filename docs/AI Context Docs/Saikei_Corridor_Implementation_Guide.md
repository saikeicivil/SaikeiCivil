# Saikei Civil Corridor Implementation Guide
## IFC 4.3 Native Corridor Modeling Reference

**Purpose:** Technical guidance for implementing corridor generation in Saikei Civil  
**Target:** Claude Code implementation of Sprint 5 corridor modeling  
**Schema:** IFC 4.3 (IFC4X3_ADD2)

---

## Overview

A corridor in Saikei Civil is created by sweeping cross-sections along a 3D alignment. The IFC 4.3 standard provides `IfcSectionedSolidHorizontal` as the native representation for this geometry.

### Core Formula

```
Corridor = Alignment3D (Directrix) + CrossSectionAssembly (Profiles) + Stations (Positions)
```

### What We're Building

```
IfcSectionedSolidHorizontal
├── Directrix: IfcCurve (3D alignment from Sprints 1-3)
├── CrossSections: LIST of IfcProfileDef (from Sprint 4)
└── CrossSectionPositions: LIST of IfcAxis2PlacementLinear (new in Sprint 5)
```

---

## IFC Entity: IfcSectionedSolidHorizontal

### Semantic Definition

From buildingSMART IFC 4.3.2:

> "An IfcSectionedSolidHorizontal is a solid model constructed by sweeping potentially varying cross sections along a curve horizontally. The solid is generated by sweeping the CrossSections between CrossSectionPositions with **linear interpolation between profile points with the same tag** along the directrix."

### Entity Hierarchy

```
IfcRepresentationItem
└── IfcGeometricRepresentationItem
    └── IfcSolidModel
        └── IfcSectionedSolid
            └── IfcSectionedSolidHorizontal
```

### EXPRESS Definition

```express
ENTITY IfcSectionedSolid
  ABSTRACT SUPERTYPE OF (ONEOF(IfcSectionedSolidHorizontal))
  SUBTYPE OF (IfcSolidModel);
  Directrix : IfcCurve;
  CrossSections : LIST [2:?] OF IfcProfileDef;
WHERE
  ConsistentProfileTypes : SIZEOF(QUERY(temp <* CrossSections | 
    CrossSections[1].ProfileType <> temp.ProfileType)) = 0;
  DirectrixIs3D : Directrix.Dim = 3;
  SectionsSameType : SIZEOF(QUERY(temp <* CrossSections | 
    TYPEOF(CrossSections[1]) :<>: TYPEOF(temp))) = 0;
END_ENTITY;

ENTITY IfcSectionedSolidHorizontal
  SUBTYPE OF (IfcSectionedSolid);
  CrossSectionPositions : LIST [2:?] OF IfcAxis2PlacementLinear;
WHERE
  CorrespondingSectionPositions : 
    SIZEOF(CrossSections) = SIZEOF(CrossSectionPositions);
  NoLongitudinalOffsets : 
    SIZEOF(QUERY(temp <* CrossSectionPositions | 
      EXISTS(temp.Location.OffsetLongitudinal))) = 0;
END_ENTITY;
```

### Attributes

| Attribute | Type | Description |
|-----------|------|-------------|
| Directrix | IfcCurve | The 3D alignment curve (from Alignment3D) |
| CrossSections | LIST [2:?] OF IfcProfileDef | Cross-section profiles at each station |
| CrossSectionPositions | LIST [2:?] OF IfcAxis2PlacementLinear | Position of each cross-section |

### Constraints (WHERE Rules)

1. **ConsistentProfileTypes:** All profiles must have same ProfileType (AREA or CURVE)
2. **DirectrixIs3D:** Directrix must be 3-dimensional
3. **SectionsSameType:** All profiles must be exact same IFC subtype
4. **CorrespondingSectionPositions:** CrossSections count must equal CrossSectionPositions count
5. **NoLongitudinalOffsets:** Positions cannot use OffsetLongitudinal

---

## Component 1: Directrix (IfcCurve)

The directrix is the 3D path along which cross-sections are swept. In Saikei Civil, this comes from the `Alignment3D` system.

### Source

Use the `IfcAlignmentCurve` or `IfcGradientCurve` from the existing alignment export.

### Requirements

- Must be 3-dimensional (Dim = 3)
- Should be tangent-continuous for smooth results
- If not tangent-continuous, IFC creates a miter at half-angle between segments

### Python Pattern

```python
def get_directrix_from_alignment(alignment_3d, ifc_file):
    """
    Extract directrix curve from Alignment3D.
    
    The directrix is the IfcAlignmentCurve that represents
    the 3D path of the alignment.
    """
    # If Alignment3D has IFC export capability
    if hasattr(alignment_3d, 'to_ifc'):
        alignment_entity = alignment_3d.to_ifc(ifc_file)
        # The Axis attribute contains the curve
        return alignment_entity.Axis
    
    # Fallback: Create polyline from sampled points
    points = []
    for station in range(0, int(alignment_3d.length) + 1, 10):
        x, y, z = alignment_3d.get_3d_position(station)
        point = ifc_file.create_entity(
            "IfcCartesianPoint",
            Coordinates=(x, y, z)
        )
        points.append(point)
    
    return ifc_file.create_entity("IfcPolyline", Points=points)
```

---

## Component 2: CrossSections (IfcProfileDef)

Cross-sections define the shape at each station along the corridor.

### Recommended Profile Type

Use `IfcArbitraryClosedProfileDef` with `IfcIndexedPolyCurve` for maximum flexibility:

```
IfcArbitraryClosedProfileDef
├── ProfileType: .AREA.
├── ProfileName: "Road Section at Sta 0+100"
└── OuterCurve: IfcIndexedPolyCurve
    ├── Points: IfcCartesianPointList2D
    │   ├── CoordList: [(x1,y1), (x2,y2), ...]
    │   └── TagList: ["CL", "ETW_L", "EPS_L", ...]  ← CRITICAL!
    └── Segments: [IfcLineIndex(...), ...]
```

### The Tag System (Critical for Interpolation)

**Tags are essential for smooth corridor generation.** The IFC viewer/processor interpolates between consecutive profiles by matching points with the same tag.

```python
# Standard tags for road cross-sections
class PointTags:
    """Standard point tags for IFC corridor interpolation."""
    
    # Centerline
    CENTERLINE = "CL"
    CROWN = "CR"
    
    # Travel lanes
    EDGE_TRAVELED_WAY_LEFT = "ETW_L"
    EDGE_TRAVELED_WAY_RIGHT = "ETW_R"
    
    # Pavement edges
    EDGE_PAVEMENT_LEFT = "EPS_L"
    EDGE_PAVEMENT_RIGHT = "EPS_R"
    
    # Curb points
    FLOWLINE_LEFT = "FL_L"
    FLOWLINE_RIGHT = "FL_R"
    BACK_CURB_LEFT = "BC_L"
    BACK_CURB_RIGHT = "BC_R"
    TOP_CURB_LEFT = "TC_L"
    TOP_CURB_RIGHT = "TC_R"
    
    # Shoulder
    HINGE_LEFT = "HG_L"
    HINGE_RIGHT = "HG_R"
    SHOULDER_LEFT = "SH_L"
    SHOULDER_RIGHT = "SH_R"
    
    # Daylight/grading
    DAYLIGHT_LEFT = "DL_L"
    DAYLIGHT_RIGHT = "DL_R"
    
    # Subgrade
    DATUM_LEFT = "DAT_L"
    DATUM_RIGHT = "DAT_R"
```

### Tag Matching Rules

1. Points with **same tag** in consecutive profiles are linearly interpolated
2. Tags must be **consistent** across all profiles for smooth transitions
3. All profiles must have the **same number of points** (for arbitrary profiles)
4. Missing or mismatched tags cause undefined/jagged geometry

### Python Pattern: Create Cross-Section Profile

```python
def create_cross_section_profile(
    ifc_file,
    points: List[Tuple[float, float]],
    tags: List[str],
    station: float
) -> Any:
    """
    Create an IFC cross-section profile with tagged points.
    
    Args:
        ifc_file: IFC file object
        points: List of (offset, elevation) tuples
        tags: List of point tags (same length as points)
        station: Station value for naming
    
    Returns:
        IfcArbitraryClosedProfileDef entity
    """
    # Validate inputs
    assert len(points) == len(tags), "Points and tags must have same length"
    assert len(points) >= 3, "Profile must have at least 3 points"
    
    # Create point list with tags
    point_list = ifc_file.create_entity(
        "IfcCartesianPointList2D",
        CoordList=points,
        TagList=tags
    )
    
    # Create line segments connecting all points
    # Indices are 1-based in IFC
    segments = []
    for i in range(len(points)):
        next_i = (i + 1) % len(points)  # Wrap around to close
        segment = ifc_file.create_entity(
            "IfcLineIndex",
            wrappedValue=(i + 1, next_i + 1)
        )
        segments.append(segment)
    
    # Create the indexed poly curve
    curve = ifc_file.create_entity(
        "IfcIndexedPolyCurve",
        Points=point_list,
        Segments=segments,
        SelfIntersect=False
    )
    
    # Create the profile definition
    profile = ifc_file.create_entity(
        "IfcArbitraryClosedProfileDef",
        ProfileType="AREA",
        ProfileName=f"Road Section at Sta {station:.2f}",
        OuterCurve=curve
    )
    
    return profile
```

### Alternative: IfcCompositeProfileDef

For corridors with multiple separate shapes (e.g., road + median + shoulders):

```python
def create_composite_profile(ifc_file, profiles: List[Any]) -> Any:
    """
    Combine multiple profiles into a composite.
    
    Use when cross-section has separate closed shapes.
    """
    return ifc_file.create_entity(
        "IfcCompositeProfileDef",
        ProfileType="AREA",
        ProfileName="Composite Road Section",
        Profiles=profiles
    )
```

### Superelevation: IfcDerivedProfileDef

For rotated cross-sections (superelevation):

```python
def create_superelevated_profile(
    ifc_file,
    base_profile: Any,
    rotation_radians: float
) -> Any:
    """
    Create a rotated profile for superelevation.
    
    Args:
        ifc_file: IFC file object
        base_profile: The parent profile to rotate
        rotation_radians: Rotation angle (positive = counterclockwise)
    
    Returns:
        IfcDerivedProfileDef entity
    """
    # Create rotation operator
    operator = ifc_file.create_entity(
        "IfcCartesianTransformationOperator2D",
        Axis1=ifc_file.create_entity(
            "IfcDirection",
            DirectionRatios=(math.cos(rotation_radians), math.sin(rotation_radians))
        ),
        Axis2=ifc_file.create_entity(
            "IfcDirection",
            DirectionRatios=(-math.sin(rotation_radians), math.cos(rotation_radians))
        ),
        LocalOrigin=ifc_file.create_entity(
            "IfcCartesianPoint",
            Coordinates=(0.0, 0.0)
        ),
        Scale=1.0
    )
    
    return ifc_file.create_entity(
        "IfcDerivedProfileDef",
        ProfileType="AREA",
        ProfileName="Superelevated Section",
        ParentProfile=base_profile,
        Operator=operator
    )
```

---

## Component 3: CrossSectionPositions (IfcAxis2PlacementLinear)

Each cross-section needs a position along the directrix.

### Entity Structure

```
IfcAxis2PlacementLinear
├── Location: IfcPointByDistanceExpression
│   ├── DistanceAlong: IfcLengthMeasure (station in meters)
│   ├── OffsetLateral: IfcLengthMeasure (optional, horizontal offset)
│   ├── OffsetVertical: IfcLengthMeasure (optional, vertical offset)
│   ├── OffsetLongitudinal: NOT ALLOWED for IfcSectionedSolidHorizontal
│   └── BasisCurve: IfcCurve (reference to directrix)
├── Axis: IfcDirection (optional, default is Z-up)
└── RefDirection: IfcDirection (optional, perpendicular to alignment)
```

### Python Pattern

```python
def create_cross_section_position(
    ifc_file,
    directrix: Any,
    station: float,
    offset_lateral: float = 0.0,
    offset_vertical: float = 0.0
) -> Any:
    """
    Create position for a cross-section along the directrix.
    
    Args:
        ifc_file: IFC file object
        directrix: The alignment curve (IfcCurve)
        station: Distance along alignment in meters
        offset_lateral: Horizontal offset (optional)
        offset_vertical: Vertical offset (optional)
    
    Returns:
        IfcAxis2PlacementLinear entity
    """
    # Create the point by distance expression
    point = ifc_file.create_entity(
        "IfcPointByDistanceExpression",
        DistanceAlong=ifc_file.create_entity(
            "IfcLengthMeasure",
            wrappedValue=station
        ),
        OffsetLateral=offset_lateral if offset_lateral != 0.0 else None,
        OffsetVertical=offset_vertical if offset_vertical != 0.0 else None,
        # OffsetLongitudinal is NOT ALLOWED - do not set it
        BasisCurve=directrix
    )
    
    # Create the placement
    # Axis and RefDirection can be None for default orientation
    # Default: Z-up, X perpendicular to alignment facing left
    placement = ifc_file.create_entity(
        "IfcAxis2PlacementLinear",
        Location=point,
        Axis=None,        # Default: Z-up
        RefDirection=None # Default: perpendicular to alignment
    )
    
    return placement
```

---

## Station Management

### Intelligent Station Calculation

Stations should be calculated based on:

1. **Base Interval:** Regular spacing (e.g., 10m)
2. **Curve Densification:** More stations in horizontal curves
3. **Vertical Geometry:** Stations at PVIs and curve quarter-points
4. **Critical Points:** User-specified locations

### Python Pattern: StationManager

```python
@dataclass
class StationPoint:
    """A station location for cross-section placement."""
    station: float      # Distance along alignment (m)
    x: float           # Easting
    y: float           # Northing
    z: float           # Elevation
    direction: float   # Horizontal bearing (radians)
    grade: float       # Vertical grade (decimal)
    reason: str        # Why this station was selected


class StationManager:
    """Calculate optimal station locations for corridor generation."""
    
    def __init__(self, alignment_3d, base_interval: float = 10.0):
        self.alignment = alignment_3d
        self.base_interval = base_interval
        self.curve_densification_factor = 2.0  # 2x denser in curves
        self.min_station_spacing = 0.5  # Minimum 0.5m between stations
    
    def generate_stations(self) -> List[StationPoint]:
        """Generate optimized station list."""
        stations = []
        
        # 1. Add base interval stations
        stations.extend(self._generate_interval_stations())
        
        # 2. Add horizontal curve stations
        stations.extend(self._generate_curve_stations())
        
        # 3. Add vertical geometry stations (PVIs)
        stations.extend(self._generate_pvi_stations())
        
        # 4. Merge close stations
        stations = self._merge_close_stations(stations)
        
        # 5. Sort by station value
        stations.sort(key=lambda s: s.station)
        
        return stations
    
    def _generate_interval_stations(self) -> List[StationPoint]:
        """Generate stations at regular intervals."""
        stations = []
        current = 0.0
        
        while current <= self.alignment.length:
            stations.append(self._create_station_point(current, "interval"))
            current += self.base_interval
        
        # Always include end station
        if stations[-1].station < self.alignment.length:
            stations.append(
                self._create_station_point(self.alignment.length, "end")
            )
        
        return stations
    
    def _generate_curve_stations(self) -> List[StationPoint]:
        """Generate denser stations in horizontal curves."""
        stations = []
        curve_interval = self.base_interval / self.curve_densification_factor
        
        for curve in self.alignment.horizontal.curves:
            # Add stations throughout curve
            current = curve.start_station
            while current <= curve.end_station:
                stations.append(
                    self._create_station_point(current, "curve")
                )
                current += curve_interval
        
        return stations
    
    def _generate_pvi_stations(self) -> List[StationPoint]:
        """Generate stations at vertical curve critical points."""
        stations = []
        
        for pvi in self.alignment.vertical.pvis:
            # Add PVI station
            stations.append(
                self._create_station_point(pvi.station, "pvi")
            )
            
            # Add curve quarter points if vertical curve exists
            if pvi.curve_length > 0:
                quarter = pvi.curve_length / 4
                stations.append(
                    self._create_station_point(
                        pvi.station - quarter, "pvi_quarter"
                    )
                )
                stations.append(
                    self._create_station_point(
                        pvi.station + quarter, "pvi_quarter"
                    )
                )
        
        return stations
    
    def _merge_close_stations(
        self, 
        stations: List[StationPoint]
    ) -> List[StationPoint]:
        """Remove duplicate/very close stations."""
        if not stations:
            return []
        
        # Sort first
        stations.sort(key=lambda s: s.station)
        
        # Priority for keeping: end > pvi > curve > interval
        priority = {"end": 4, "pvi": 3, "curve": 2, "interval": 1}
        
        merged = [stations[0]]
        for station in stations[1:]:
            if station.station - merged[-1].station < self.min_station_spacing:
                # Keep higher priority station
                if priority.get(station.reason, 0) > priority.get(merged[-1].reason, 0):
                    merged[-1] = station
            else:
                merged.append(station)
        
        return merged
    
    def _create_station_point(self, station: float, reason: str) -> StationPoint:
        """Create a StationPoint from alignment data."""
        x, y, z = self.alignment.get_3d_position(station)
        direction = self.alignment.get_direction(station)
        grade = self.alignment.get_grade(station)
        
        return StationPoint(
            station=station,
            x=x, y=y, z=z,
            direction=direction,
            grade=grade,
            reason=reason
        )
```

---

## Putting It All Together: CorridorModeler

### Complete Implementation Pattern

```python
class CorridorModeler:
    """
    Create IFC corridor solids from Alignment3D and CrossSectionAssembly.
    
    This class combines:
    - Alignment3D (directrix)
    - CrossSectionAssembly (profiles)
    - StationManager (positions)
    
    To produce:
    - IfcSectionedSolidHorizontal (3D corridor solid)
    """
    
    def __init__(
        self,
        alignment: 'Alignment3D',
        assembly: 'CrossSectionAssembly'
    ):
        self.alignment = alignment
        self.assembly = assembly
        self.station_manager = StationManager(alignment)
        self.stations: List[StationPoint] = []
        self.ifc_file = None
        self.corridor_solid = None
    
    def create_corridor_solid(
        self,
        ifc_file = None,
        interval: float = 10.0
    ) -> Any:
        """
        Create the IfcSectionedSolidHorizontal corridor.
        
        Args:
            ifc_file: Existing IFC file or None to create new
            interval: Base station interval in meters
        
        Returns:
            IfcSectionedSolidHorizontal entity
        """
        # Setup IFC file
        if ifc_file is None:
            self.ifc_file = ifcopenshell.file(schema="IFC4X3")
        else:
            self.ifc_file = ifc_file
        
        # Generate stations
        self.station_manager.base_interval = interval
        self.stations = self.station_manager.generate_stations()
        
        if len(self.stations) < 2:
            raise ValueError("Need at least 2 stations for corridor")
        
        # Create directrix
        directrix = self._create_directrix()
        
        # Create cross-sections for each station
        cross_sections = self._create_cross_sections()
        
        # Create positions for each station
        positions = self._create_positions(directrix)
        
        # Create the corridor solid
        self.corridor_solid = self.ifc_file.create_entity(
            "IfcSectionedSolidHorizontal",
            Directrix=directrix,
            CrossSections=cross_sections,
            CrossSectionPositions=positions
        )
        
        return self.corridor_solid
    
    def _create_directrix(self) -> Any:
        """Create the 3D alignment curve."""
        # Try to use alignment's IFC export
        if hasattr(self.alignment, 'get_alignment_curve'):
            return self.alignment.get_alignment_curve(self.ifc_file)
        
        # Fallback: Create polyline from station points
        points = []
        for sp in self.stations:
            point = self.ifc_file.create_entity(
                "IfcCartesianPoint",
                Coordinates=(sp.x, sp.y, sp.z)
            )
            points.append(point)
        
        return self.ifc_file.create_entity(
            "IfcPolyline",
            Points=points
        )
    
    def _create_cross_sections(self) -> List[Any]:
        """Create cross-section profiles for each station."""
        profiles = []
        
        for station_point in self.stations:
            # Get cross-section geometry at this station
            # The assembly may have parametric variations
            points, tags = self.assembly.get_profile_at_station(
                station_point.station
            )
            
            # Create the IFC profile
            profile = create_cross_section_profile(
                self.ifc_file,
                points,
                tags,
                station_point.station
            )
            profiles.append(profile)
        
        return profiles
    
    def _create_positions(self, directrix: Any) -> List[Any]:
        """Create positions for each cross-section."""
        positions = []
        
        for station_point in self.stations:
            position = create_cross_section_position(
                self.ifc_file,
                directrix,
                station_point.station
            )
            positions.append(position)
        
        return positions
```

---

## IFC Road Spatial Structure

### Where the Corridor Solid Lives

The corridor solid exists within the IFC spatial hierarchy:

```
IfcProject
└── IfcSite
    └── IfcRoad
        ├── IfcAlignment (reference)
        └── IfcRoadPart (UsageType: LONGITUDINAL)
            └── IfcPavement (or IfcCourse, etc.)
                └── Representation
                    └── IfcShapeRepresentation
                        └── IfcSectionedSolidHorizontal  ← HERE
```

### Key Relationships

| Relationship | Purpose |
|--------------|---------|
| IfcRelAggregates | Spatial hierarchy (Site → Road → RoadPart) |
| IfcRelContainedInSpatialStructure | Physical elements in spatial structure |
| IfcRelAssociatesMaterial | Material assignment to corridor |

### RoadPart Usage Types

```
IfcFacilityUsageEnum:
├── LONGITUDINAL  - Road segments along alignment
├── LATERAL       - Cross-sectional zones (carriageway, shoulder)
├── REGION        - General area
└── VERTICAL      - Vertical zones (rarely used for roads)
```

### RoadPart Predefined Types

```
IfcRoadPartTypeEnum:
├── ROADSEGMENT        - General road segment
├── ROADSIDE           - Roadside area
├── SIDEWALK           - Pedestrian path
├── PARKINGBAY         - Parking area
├── TOLLPLAZA          - Toll collection
├── INTERSECTION       - Road intersection
├── PEDESTRIAN_CROSSING
├── SOFTSHOULDER
├── HARDSHOULDER
├── CENTRALISLAND
├── TRAFFICISLAND
└── etc.
```

---

## Material Association

### IfcMaterialProfileSet for Pavement Layers

```python
def create_material_profile_set(ifc_file, corridor_solid) -> Any:
    """
    Create material associations for corridor layers.
    """
    # Create materials
    asphalt = ifc_file.create_entity(
        "IfcMaterial",
        Name="Asphalt Concrete"
    )
    
    aggregate = ifc_file.create_entity(
        "IfcMaterial",
        Name="Crusite Aggregate Base"
    )
    
    # Create material profiles (simplified - would have actual profile geometry)
    wearing_course = ifc_file.create_entity(
        "IfcMaterialProfile",
        Name="Wearing Course",
        Material=asphalt,
        Priority=1
    )
    
    base_course = ifc_file.create_entity(
        "IfcMaterialProfile",
        Name="Base Course",
        Material=aggregate,
        Priority=2
    )
    
    # Create profile set
    profile_set = ifc_file.create_entity(
        "IfcMaterialProfileSet",
        Name="Road Pavement",
        MaterialProfiles=[wearing_course, base_course]
    )
    
    return profile_set
```

---

## Validation Checklist

Before generating a corridor, verify:

- [ ] Directrix is 3D (Dim = 3)
- [ ] At least 2 cross-sections
- [ ] All profiles have same ProfileType (AREA)
- [ ] All profiles are same IFC subtype
- [ ] CrossSections count equals CrossSectionPositions count
- [ ] No OffsetLongitudinal in any position
- [ ] Tags are consistent across all profiles
- [ ] Directrix does not self-intersect

---

## Common Pitfalls

1. **Mismatched Tags:** Points without matching tags between profiles won't interpolate smoothly
2. **Different Profile Types:** Mixing IfcArbitraryClosedProfileDef with IfcRectangleProfileDef will fail
3. **OffsetLongitudinal:** Setting this on positions violates IFC constraints
4. **Too Few Stations:** Need minimum 2, but curves need many more for smooth geometry
5. **Non-3D Directrix:** 2D curves will fail validation
6. **Self-Intersecting Profiles:** Invalid geometry will cause viewer errors

---

## File Locations in Saikei Civil

```
blendercivil/
├── core/
│   ├── corridor/
│   │   ├── __init__.py
│   │   ├── modeler.py          # CorridorModeler class
│   │   ├── station_manager.py  # StationManager class
│   │   └── tags.py             # PointTags constants
│   └── cross_section/          # From Sprint 4
│       └── assembly.py
├── operators/
│   └── corridor_ops.py         # Blender operators
└── ui/
    └── corridor_panel.py       # UI panels
```

---

## References

- buildingSMART IFC 4.3.2 Documentation: IfcSectionedSolidHorizontal
- buildingSMART IFC 4.3.2 Documentation: IfcRoad, IfcRoadPart
- IFC-Road WP3 Conceptual Model Report (Annex I)
- Saikei Civil Sprint 1-4 Implementation

---

*Guidance document for Saikei Civil Sprint 5 implementation*
